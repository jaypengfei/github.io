---
layout: post
title:  Java中的各种锁
date:   2018-04-20 10:19:00 +0800
categories: Java
tag: lock
---

* content
{:toc}
<hr>

1.公平锁和非公平锁
------------------------------------

多个线程在等待同一个锁时，必须按照申请锁的先后顺序来依次获得锁。好处是等待锁的线程不会饿死，但是整体效率低一些，非公平锁的好处是整体效率相对较高一些，但是有些线程可能会饿死或者说等待时间可能会过长。因为非公平锁是可以抢占的，即如果某个时刻又线程需要获得锁，而这时候刚好锁可用，那么这个线程会直接抢占。

公平锁可以使用 **new ReentrantLock(true)** 实现。

## 2.自旋锁

Java中的线程是**映射到操作系统的原生线程之上**的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成。这就**需要从用户态转移到核心态**中，因此状态转换需要耗费较多的处理器时间，对于代码简单的同步块（比如被synchronized修饰的getter setter），状态转换消耗的时间可能会比用户代码执行的时间还要长。

虚拟机开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得。如果物理机有一个以上的处理器，能够让两个或以上的线程同时并发执行，我们就可以让后面请求锁的哪个线程“稍微等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需要让线程执行一个**忙循环（自旋）**，这项技术就是所谓的自旋锁。

自旋锁在JDK1.4.2中引入，使用**-XX:+userSpining**来开启，不过JDK1.6中已经默认开启，并且引入了自适应的自旋锁，自适应意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定。

**自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。**

*如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。*

## 3.锁消除

锁消除是虚拟机JIT在运行时，对一些代码上要求同步，但是检测出不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据是来源于[逃逸分析](https://www.jianshu.com/p/20bd2e9b1f03)的数据支持，如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把他们当作栈上数据对待，认为其是线程私有的，同步加锁自然就无需进行。

来看这样一个方法：

```java
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s30);
    return sb.toString();
}
```

其中，StringBuffer的append方法定义如下：

```java
public synchronized StringBuffer append(StringBuffer sb) {
    super.append(sb);
    return this;
}
```

也就是说在concatString()方法中涉及了同步操作。但是可以观察到sb对象它的作用域被限制在方法的内部，也就是sb对象不会“逃逸”出去，其他线程无法访问。因此，虽然这里有锁，但是可以被安全的消除，**在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了**。

## 4.锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁禁止，那等待的线程也能尽快拿到锁。大部分情况下，这些都是正确的。但是，如果一些列的联系操作都是同一个对象反复加解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。

举个案例，类似锁消除的concatString()方法。如果StringBuffer sb = new StringBuffer();定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个append()操作之前和最后一个append()操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。

## 5.可重入锁

可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。

在JAVA环境下 ReentrantLock和synchronized都是可重入锁。可重入锁最大的作用是避免死锁。

## 6.类锁和对象锁

关于类锁和对象锁，其实在前面的一篇关于[synchronized](http://qianpengfei.cn/2018/04/17/java-synchronized/)的文章中已经有所介绍，现在来看一个例子加深一下对对象锁和类锁的理解。

有一个类定义如下：

```java
public class synchronizedTest {
    public synchronized void method1() {}
    public synchronized void method2() {}
    public static synchronized void method3() {}
    public static synchronized void method4() {}
}
```

那么，由synchronizedTest的两个实例a和b，对于以下几个选项有哪些能被一个以上的线程同时访问呢？

```java】
A. a.method1() a.method2()
B. a.method1() b.method1()  可以同时访问
C. a.method3() b.method4()
D. a.method3() b.method3()
E. a.method1() a.method3()  可以同时访问
```

## 7.偏向锁、轻量级锁和重量级锁

### 7.1 偏向锁

大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。另外，JVM对那种会有多线程加锁，但不存在锁竞争的情况也做了优化，听起来比较拗口，但在现实应用中确实是可能出现这种情况，因为线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳（真实地生成一个时间戳代价还是蛮大的，因此这里应当理解为一种类似时间戳的identifier）

> 偏向锁的获取

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

> 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word，要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

> 偏向锁的设置

关闭偏向锁：偏向锁在Java6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟-XX：BiasedLockingStartupDelay = 0。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁-XX:-UseBiasedLocking=false，那么默认会进入轻量级锁状态。

### 7.2 轻量级锁

> 加锁

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。

> 解锁

轻量级解锁时，会使用原子的CAS操作来将DisplacedMark Word替换回到对象头，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。

### 7.3 重量级锁

重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。

> 偏向锁、轻量级锁和重量级锁之间的比较
>

|    锁    |                             优点                             |                      缺点                      |               适用场景               |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :----------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |   适用于只有一个线程访问同步块场景   |
| 轻量级锁 |           竞争的线程不会阻塞，提高了程序的响应速度           |   如果始终得不到锁竞争的线程，会自旋消耗CPU    | 最求响应时间，同步代码块执行速度较快 |
| 重量级锁 |                线程竞争不使用自旋，不消耗CPU                 |             线程阻塞，响应时间缓慢             |    追求吞吐量，同步块执行时间较长    |

## 8.悲观锁和乐观锁

> 悲观锁

是一种悲观的并发控制机制。假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作，但这会带来性能上的损失（例如**例如synchronized）**）。悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理提供了保证。但是在效率方面，处理加锁会产生额外的开销，还会增加死锁的机会。

> 乐观锁

假定不会发生并发冲突，只是在提交操作时检测是否违反数据完整性（使用版本号）。如果确实未发生竞争，那么直接提交操作，否则重新竞争。（例如**CAS**）

## 9.共享锁和排他锁

> 共享锁

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。

> 排它锁

如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。

## 10.读写锁

读写锁是一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。

## 11.互斥锁

所谓互斥锁就是指一次最多只能有一个线程持有的锁。在JDK中synchronized和J.U.C的Lock就是互斥锁。

## 12.无锁

要保证现场安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。

- 无状态编程。无状态代码有一些共同的特征：不依赖于存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。
- 线程本地存储。可以参考ThreadLocal
-  [volatile](http://qianpengfei.cn/2018/04/17/java-volatile/)
- CAS
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换









<hr>
​最后的最后，老婆我爱你。








