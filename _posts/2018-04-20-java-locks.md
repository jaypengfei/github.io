---
layout: post
title:  Java中的各种锁
date:   2018-04-20 10:19:00 +0800
categories: Java
tag: lock
---

* content
{:toc}
<hr>

1.公平锁和非公平锁
------------------------------------

多个线程在等待同一个锁时，必须按照申请锁的先后顺序来依次获得锁。好处是等待锁的线程不会饿死，但是整体效率低一些，非公平锁的好处是整体效率相对较高一些，但是有些线程可能会饿死或者说等待时间可能会过长。因为非公平锁是可以抢占的，即如果某个时刻又线程需要获得锁，而这时候刚好锁可用，那么这个线程会直接抢占。

公平锁可以使用 **new ReentrantLock(true)** 实现。

## 2.自旋锁

Java中的线程是**映射到操作系统的原生线程之上**的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成。这就**需要从用户态转移到核心态**中，因此状态转换需要耗费较多的处理器时间，对于代码简单的同步块（比如被synchronized修饰的getter setter），状态转换消耗的时间可能会比用户代码执行的时间还要长。

虚拟机开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得。如果物理机有一个以上的处理器，能够让两个或以上的线程同时并发执行，我们就可以让后面请求锁的哪个线程“稍微等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需要让线程执行一个**忙循环（自旋）**，这项技术就是所谓的自旋锁。

自旋锁在JDK1.4.2中引入，使用**-XX:+userSpining**来开启，不过JDK1.6中已经默认开启，并且引入了自适应的自旋锁，自适应意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定。

**自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。**

*如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。*

## 3.锁消除

锁消除是虚拟机JIT在运行时，对一些代码上要求同步，但是检测出不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据是来源于[逃逸分析](https://www.jianshu.com/p/20bd2e9b1f03)的数据支持，如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把他们当作栈上数据对待，认为其是线程私有的，同步加锁自然就无需进行。

来看这样一个方法：

```java
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s30);
    return sb.toString();
}
```

其中，StringBuffer的append方法定义如下：

```java
public synchronized StringBuffer append(StringBuffer sb) {
    super.append(sb);
    return this;
}
```

也就是说在concatString()方法中涉及了同步操作。但是可以观察到sb对象它的作用域被限制在方法的内部，也就是sb对象不会“逃逸”出去，其他线程无法访问。因此，虽然这里有锁，但是可以被安全的消除，**在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了**。

## 4.锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁禁止，那等待的线程也能尽快拿到锁。大部分情况下，这些都是正确的。但是，如果一些列的联系操作都是同一个对象反复加解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。

举个案例，类似锁消除的concatString()方法。如果StringBuffer sb = new StringBuffer();定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个append()操作之前和最后一个append()操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。

## 5.可重入锁

可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。

在JAVA环境下 ReentrantLock和synchronized都是可重入锁。可重入锁最大的作用是避免死锁。

## 6.类锁和对象锁

关于类锁和对象锁，其实在前面的一篇关于[synchronized](http://qianpengfei.cn/2018/04/17/java-synchronized/)的文章中已经有所介绍，现在来看一个例子加深一下对对象锁和类锁的理解。

有一个类定义如下：

```java
public class synchronizedTest {
    public synchronized void method1() {}
    public synchronized void method2() {}
    public static synchronized void method3() {}
    public static synchronized void method4() {}
}
```

那么，由synchronizedTest的两个实例a和b，对于以下几个选项有哪些能被一个以上的线程同时访问呢？

```java】
A. a.method1() a.method2()
B. a.method1() b.method1()  可以同时访问
C. a.method3() b.method4()
D. a.method3() b.method3()
E. a.method1() a.method3()  可以同时访问
```















<hr>
​最后的最后，老婆我爱你。








