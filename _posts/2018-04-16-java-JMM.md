---
layout: post
title:  Java内存模型以及happens-before规则
date:   2018-04-16 15:19:00 +0800
categories: Java
tag: JMM
---

* content
{:toc}




本文转载自[简书]( https://www.jianshu.com/p/d52fea0d6ba5)

<hr>

1.JMM
====================================

在多线程中很容易出现线程安全的问题

> 线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

出现线程安全的问题一般是因为**主内存和工作内存数据不一致性和重排序**导致的，而解决线程安全的问题最重要的就是理解这两种问题产生的原因，所以关键在于理解Java内存模型（JMM）。

在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等，另外为了性能优化，还会涉及到编译器指令重排序和处理器指令重排序。

2.内存模型抽象结构
====================================

线程之间的协作通信可以类比人与人之间的协作方式，我们以“妈妈喊小明回家吃饭”为例，小明在外面玩耍，妈妈在家里做饭，做完晚饭后准备叫小明回家吃饭，那么就存在以下两种方式：

- 妈妈要去上班了，这个时候收集又恰好没有电了，于是就在桌子上贴了一张纸条：饭做好了，放在厨房，抓紧吃。小明回到家以后看到纸条，知道饭已经做好可以吃了。那么如果将小明和妈妈比作两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写共享变量实现两个线程间协作。
- 还有一种方式就是，妈妈的收集还有电，妈妈在赶去上班的路上给小明打了个电话，这种方式就是通知机制来完成协作。同样，可以引申到线程间的通信机制。

通过上面这个例子，英爱有些认识。在并发编程中主要需要解决连个问题：

1. 线程之间如何通信？
2. 线程之间如何同步？

通信指的是线程之间以何种机制来交换信息，主要有两种：**共享内存和消息传递**。这里可以类比上面的两个例子。Java内存模型是**共享内存的并发模式**，线程之间主要通过读写共享变量来完成隐式通信。

## 2.1 哪些是共享变量？

在Java程序中所有的实例域，静态域和数组元素都是放在堆内存中（所有线程共享的），而局部变量，方法定义参数和异常处理参数不会在线程间共享。共享数据会出现线程安全的问题，而非共享数据则不会存在线程安全的问题。

## 2.2 JMM抽象结构模型

我们知道CPU的处理速度和主存的读写数度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。因此，共享变量会先放到主存中，每个线程都会有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回主内存中去。JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

所以两个线程：A和B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中将共享变量读入其工作内存后并进行操作，之后将数据重新写回到主内存中
2. 线程B从主内存中读取最新的共享变量

从横向去看的话，A和B就好像通过共享变量在进行隐式通信，这里存在一个问题，如果A更新数据后并没有及时写回到主内存，而此时B读到的是过期的数据，这就出现了“脏读”。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主存中，从而使得其对其他线程是可见的。

3.重排序
====================================

一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都是为了同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。JMM对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：

![](D:\GitHub\jaypengfei.github.io\styles\images\java_reorder.png)

​								图1 从源码到最终执行指令序列的示意图

1. 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2. 指令级别并行的重排序：现代处理器采用了指令级并行技术来讲多条指令重叠执行。如果**不存在数据依赖性**，处理器可以改变语句对应机器指令的执行顺序；
3. 内存系统的重排序：由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。

如图，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，一个经典的例子就是DCL问题。针对编译器重排序，JMM的编译器重排序规则会**禁止一些特定类型的编译器重排序**；针对处理器重排序，编译器在生成指令序列的时候会通过插入**内存屏障指令来禁止某些特殊的处理器重排序**。

那么什么情况下，不能进行重排序了？下面来说说数据依赖性：

```java
double pi = 3.14;//A
double r = 1.0;//B
double area = pi * r * r;//C
```

这是一个计算圆面积的代码，由于A和B之间没有任何关系，对最终结果也不会存在关系，他们之间的执行顺序可以重排序。因此可以执行顺序是A-B-C或者B-A-C，最终的间而过都是3.14，即AB之间不存在数据依赖性。具体的定义为：**如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依辣性**。这里存在三种情况：

1. 读后写
2. 写后写
3. 写后读

以上三种操作都存在数据依辣性，如果重排序对最终执行结果存在影响。编译器和处理器在重排序时，会遵守数据依辣性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。

## 3.1 as-if-serial

as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。as-if-serial语义把单线程程序保护了起来，**遵守该语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。比如上面计算面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行的**。实际AB两行不存在数据依赖性可能会进行重排序，即AB不是顺序执行的。as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。

4.happens-before规则
====================================

上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则，下面以两个方面来说。

## 4.1 happens-before定义

happens-before的概念最初由Leslie Lamport在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出，有兴趣的可以去看一下。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，**JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证**（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第一个操作之前。
2. 如果两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不违法（JMM允许）。

上面的1.**是JMM对程序员的承诺**。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！

上面的2.**是JMM对编译器和处理器重排序的约束原则**。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。

***as-if-serial VS happens-be***

1. as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
2. as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确通融不的多线程程序员创造了一个幻境：正确同步的多线程程序是按照happens-before指定的顺序来执行的。
3. as-if-serial和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。

# 5.总结



<hr>
​最后的最后，老婆我爱你。








