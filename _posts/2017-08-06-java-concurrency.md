---
layout: post
title:  Java Concurrency
date:   2017-08-06 15:52:00 +0800
categories: Java
tag: Concurrency
---

* content
{:toc}


本文参考《Java Concurrency in Practice》。
<hr>

4.对象的组合
====================================

我们并不希望对每次一的内存访问都进行分析以确保程序是线程安全的，而是希望将一些现有的线程安全组件组合为更大规模的组件或程序。这一章将介绍一些组合模式，这些模式能够使一个类更容易称为线程安全的，并且在维护这些类时不会无意中破坏类的安全保证。<br>

4.1设计线程安全的类
-----------------------------------
在线程安全的程序中，虽然可以将程序的所有状态都保存在公有的静态域中，但与那些将状态封装起来的程序相比，这些程序的线程安全性更难以得到验证，并且在修改时也更难以确保其线程安全性。通过使用封装技术，可以使得在不对整个程序进行分析的情况下就可以判断一个类是否是线程安全的。<br>
在设计线程安全类的过程中，需要包含以下三个基本要素：
+ 找出构成对象状态的所有变量。

+ 找出约束状态变量的不变性条件。

+ 建立对象状态的并发访问管理策略。

要分析对象的状态，首先从对象的域开始。如果对象中的所有域都是基本类型的变量，那么这些域将构成对象的全部状态。程序4-1中的Counter只有一个域value，因此这个域就是Counter的全部状态。对于含有n个基本类型域的对象，其状态就是这些域构成的n元组。例如，二维点的状态就是它的坐标值（x，y）。**如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域**。例如LinkedList的状态就包括该链表中所有节点对象的状态。

  ``` java
//程序4-1 使用Java监视器模式的线程安全计数器  
@ThreadSafe
  public final class Counter {
  	@GuardedBy("this") private long value = 0;
    	public synchronized long getValue() {
        return value;
    	}
    	public synchronized long increment() {
        if(value == Long.MAX_VALUE)
          throw new illegalStateException("counter overflow");
        return ++value;
    	} 
  }
  ```

同步策略（synchronization Policy）定义了如何在不违背对象不变性条件或后验条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量由哪些锁来保护。要确保开发人员可以对这个类进行分析与维护，就必须将同步策略写为正式文档。

4.1.1 收集同步需求

要确保类的线程安全性，就需要确保它的`不可变性条件`不会再并发访问的情况下被破坏，这就需要对其状态进行推断。对象和变量都有一个状态空间，即所有可能的取值。状态空间越小，就越容易判断线程的状态。final类型的域使用的越多，就越能简化对象可能状态的分析过程。（极端情况下，不可变对象只有唯一的状态）

在许多类中都定义了一些不可变条件，用于判断状态是否有效。Counter中的value域是long类型的变量，其状态空间从Long.MIN_VALUE到Long.MAX_VALUE，但value在取值范围上存在着一个限制，即不能为负值。

同样，在操作中还会包含一些`后验条件`来判断状态迁移是否是有效的。如果Counter的当前状态是17，那么下一个有效状态只能是18。**当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作**。并非所有的操作都会在状态转换上施加限制，例如，当更新一个保存当前温度的变量时，该变量之前的状态并不会影响计算结果。

由于不变性以及后验条件在状态及状态转换上施加了各种约束，因此就需要额外的同步与封装。如果某些状态是无效的，那么必须对底层的状态变量进行封装，否则客户代码可能会使对象处于无效状态。**如果在某个操作中存在无效的状态转换。那么该操作必须是原子的**。另外，如果在类中没有施加这种约束，那么就可以放宽封装性或序列化等需求，以便获得更高的灵活性或性能。

在类中也可以包含同时约束多个状态变量的不变性条件，在一个表示数值范围的类中可以包含两个状态的变量，分别表示范围的上下界。这些变量必须遵守的约束是：下界值应小于或等于上届值。类似于这种包含多个变量的不变性条件将带来原子性的需求：这些相关变量必须在单个原子操作中进行读取或更新。不能先更新一个变量，然后释放锁并再次获得锁，然后在更新其他变量。**因为释放锁后，可能会使对象处于无效状态**。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须保护这些变量的锁。

> 如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。

4.1.2依赖状态的操作

<hr>
​最后的最后，老婆我爱你。








